# --- Stage 1: Build the application ---
# Use an official Gradle image with JDK 17 as the build environment.
# 'alpine' versions are smaller and more secure.
FROM gradle:8.4-jdk17-alpine AS build

# Set the working directory inside the container.
WORKDIR /app

# Copy only the Gradle build files first. This helps Docker cache these layers.
# If these files don't change, Docker won't re-download dependencies.
COPY build.gradle settings.gradle ./
COPY gradle ./gradle

# Copy the source code last. Changes to source code invalidate this layer and subsequent layers.
COPY src ./src

# Build the application into a 'fat JAR' (executable JAR).
# '-x test' skips running tests during the Docker build, which is common for CI/CD environments
# to save time, assuming tests are run elsewhere.
RUN gradle bootJar -x test

# --- Stage 2: Run the application (leaner runtime image) ---
# Use a lightweight official OpenJDK 17 runtime image. 'slim-buster' is common.
# This image only contains the Java Runtime Environment (JRE), not the full JDK,
# making the final image smaller and more secure.
FROM openjdk:17-jdk-slim-buster

# Set the working directory for the runtime stage.
WORKDIR /app

# Copy the built JAR file from the 'build' stage into the 'app' directory
# The JAR is usually found in build/libs/ and has a name like 'your-project-name-version.jar'.
# We copy it as 'app.jar' for simplicity.
COPY --from=build /app/build/libs/*.jar app.jar

# Expose the port that your Spring Boot application listens on (default is 8080).
# This tells Docker that the container will listen on this port.
EXPOSE 8080

# Define the command to run your application when the container starts.
# 'java -jar app.jar' executes the fat JAR.
ENTRYPOINT ["java", "-jar", "app.jar"]